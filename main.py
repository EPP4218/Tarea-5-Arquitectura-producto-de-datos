# -*- coding: utf-8 -*-
"""house_prices.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Y8_Ku_uBjn8reS58rjgPwCZqdNraBMJq

# Predicting Housing Data

Datos:

* [House Prices - Advanced Regression Techniques](https://www.kaggle.com/competitions/house-prices-advanced-regression-techniques)
"""

#Importar paquetes (módulos)
from src import carga_datos 
from src import eda
from src import limpieza_datos
from src import preprocesamiento_datos
from src import modelo
import logging
import pytest 
import argparse



#Se define función para loggear
def init_logging():
    """Inicializa la configuración básica para guardar los mensajes logs.
    """
    try:
        logging.basicConfig(
                            filename='logs_carpeta/results.log',
                            level=logging.INFO,
                            filemode='w',
                            format='%(name)s - %(levelname)s - %(message)s'
                        )
    except RuntimeError:
        logging.error("Logging no puede comenzar")

"""## Load data"""

#Inicializar la configuración de los loggins
init_logging()
#Cargar datos de entrenamiento y de prueba


try:  
  parser = argparse.ArgumentParser(prog="Introduce ""Run", 
                                   usage="Interta la instrucción deseada, se sugiere: 'Run'",
                                   description="El usuario solo debe introducir la palabra Run",
                                   epilog="Run")
  parser.add_argument('column', type=str)
  args = parser.parse_args()
  train_data = carga_datos.obtener_datos("train")
  test_data = carga_datos.obtener_datos("test")
  #Guardar la identificación de las observaciones de los datos de prueba
  test_ids = test_data['Id']
  logging.debug(f"Tamaño base = {train_data.shape}")
  logging.debug(f"Datos duplicados = {train_data.duplicated().sum()}") 
except FileNotFoundError as err:
  train_data, train_data = None, None
  logging.error("La ruta de los datos de entrenamiento o de prueba esta mal.")
  logging.debug(err)
except: 
    print(" ERRROR : Se debe escribir main.py 'Run'")
    logging.error("Parametro erroneo del usuario")

"""## Some EDA"""

#Graficar para cononocer los Na's de las variables
eda.grafica_na(train_data)

#Graficar distribuciones de variables de interés

try: 
  eda.grafica_barras(train_data['SaleCondition'])
  eda.grafica_histograma(train_data['SaleType'])
  eda.grafica_violin(train_data['HouseStyle'], 
                    train_data['SalePrice'])
  eda.grafica_dispersion(train_data["Foundation"],
                        train_data["SalePrice"])

except KeyError as error:
  logging.error("Alguna de las variables seleccionadas no existe.")
  logging.debug(error)

"""## Fill missing data"""

#Llenar datos faltantes de los datos de entrenamiento y prueba para ciertas 
#variables

try:  
  limpieza_datos.llenado_datos_faltantes(train_data, 
                                        ['FireplaceQu', 'BsmtQual', 
                                          'BsmtCond', 'BsmtFinType1',
                                          'BsmtFinType2'],"No")
  limpieza_datos.llenado_datos_faltantes(test_data, 
                                        ['FireplaceQu', 'BsmtQual', 
                                          'BsmtCond', 'BsmtFinType1',
                                          'BsmtFinType2'],"No")
  #Llenar los datos faltantes de todas las variables para los datos de 
  #entrenamiento y prueba
  limpieza_datos.llenado_todos_datos_faltantes(train_data)
  limpieza_datos.llenado_todos_datos_faltantes(test_data) 
except KeyError as error:
  logging.error("Alguna de las variables seleccionadas no existe.\
  No fue posible hacer la limpieza de datos.")
  logging.debug(error)
except NameError as error2:
  logging.error("El nombre de alguna base es erróneo.\
  No fue posible hacer la limpieza de datos.")
  logging.debug(error2)

"""## Drop unwanted data"""

try: 
  #Seleccionar columnar a quitar
  drop_col = ['Id', 'Alley', 'PoolQC', 'MiscFeature', 'Fence', 'MoSold', 'YrSold', 
            'MSSubClass',
            'GarageType', 'GarageArea', 'GarageYrBlt', 'GarageFinish', 
            'YearRemodAdd', 'LandSlope',
            'BsmtUnfSF', 'BsmtExposure', '2ndFlrSF', 'LowQualFinSF', 
            'Condition1', 
            'Condition2', 'Heating',
             'Exterior1st', 'Exterior2nd', 'HouseStyle', 'LotShape', 
            'LandContour', 'LotConfig', 'Functional',
             'BsmtFinSF1', 'BsmtFinSF2', 'FireplaceQu', 'WoodDeckSF', 
            'GarageQual', 'GarageCond', 'OverallCond'
           ]

  #Quitar columnas no deseadas
  limpieza_datos.quitar_columnas(train_data, drop_col)
  limpieza_datos.quitar_columnas(test_data, drop_col)
except KeyError as error:
  logging.error("Alguna de las variables seleccionadas no existe.\
  No fue posible quitar las variables seleccionadas.")
  logging.debug(error)
except NameError as error2:
  logging.error("El nombre de alguna base es erróneo.\
  No fue posible quitar las variables seleccionadas.")
  logging.debug(error2)

"""## Preprocessing"""

try:
  #Decodificar las variables categóricas de acuerdo al orden de sus categorías

  preprocesamiento_datos.trans_variables_categoricas(train_data, test_data,
                                                    ['BsmtQual', 'BsmtCond'],
                                                    ['No', 'Po', 'Fa', 'TA', 
                                                      'Gd', 'Ex'])

  preprocesamiento_datos.trans_variables_categoricas(train_data, test_data,
                                                    ['ExterQual', 'ExterCond',
                                                      'KitchenQual'],['Po', 'Fa', 
                                                                      'TA', 'Gd', 
                                                                      'Ex'])

  preprocesamiento_datos.trans_variables_categoricas(train_data, test_data,
                                                    ['PavedDrive'],
                                                    ['N', 'P', 'Y'])

  preprocesamiento_datos.trans_variables_categoricas(train_data, test_data,
                                                    ['Electrical'],
                                                    ['Mix', 'FuseP', 'FuseF',
                                                      'FuseA', 'SBrkr'])

  preprocesamiento_datos.trans_variables_categoricas(train_data, test_data,
                                                    ['BsmtFinType1',
                                                      'BsmtFinType2'],
                                                    ['No', 'Unf', 'LwQ', 
                                                      'Rec', 'BLQ', 'ALQ', 'GLQ'])

  preprocesamiento_datos.trans_variables_categoricas(train_data, test_data,
                                                    ['Utilities'],
                                                    ['ELO', 'NoSeWa', 
                                                      'NoSewr', 'AllPub'])

  preprocesamiento_datos.trans_variables_categoricas(train_data, test_data,
                                                    ['MSZoning'],
                                                    ['C (all)', 'RH', 
                                                      'RM', 'RL', 'FV'])

  preprocesamiento_datos.trans_variables_categoricas(train_data, test_data,
                                                    ['Foundation'],
                                                    ['Slab', 'BrkTil', 'Stone', 
                                                      'CBlock', 'Wood', 'PConc'])

  preprocesamiento_datos.trans_variables_categoricas(train_data, test_data,
                                                    ['Neighborhood'],
                                                    ['MeadowV', 'IDOTRR', 
                                                      'BrDale', 'Edwards', 
                                                      'BrkSide', 'OldTown', 
                                                      'NAmes', 'Sawyer', 
                                                      'Mitchel', 
                                                      'NPkVill', 'SWISU', 
                                                      'Blueste', 'SawyerW', 
                                                      'NWAmes', 'Gilbert', 
                                                      'Blmngtn', 'ClearCr', 
                                                      'Crawfor', 'CollgCr', 
                                                      'Veenker', 'Timber', 
                                                      'Somerst', 'NoRidge', 
                                                      'StoneBr', 'NridgHt'])

  preprocesamiento_datos.trans_variables_categoricas(train_data, test_data,
                                                    ['MasVnrType'],
                                                    ['None', 'BrkCmn', 
                                                      'BrkFace', 'Stone'])

  preprocesamiento_datos.trans_variables_categoricas(train_data, test_data,
                                                    ['SaleCondition'],
                                                    ['AdjLand', 'Abnorml',
                                                      'Alloca', 'Family', 
                                                      'Normal', 'Partial'])


  preprocesamiento_datos.trans_variables_categoricas(train_data, 
                                                    test_data,['RoofStyle'],
                                                    ['Gambrel', 'Gable','Hip', 
                                                      'Mansard', 'Flat', 'Shed'])

  preprocesamiento_datos.trans_variables_categoricas(train_data, test_data,
                                                    ['RoofMatl'],
                                                    ['ClyTile', 'CompShg', 
                                                      'Roll','Metal', 'Tar&Grv',
                                                      'Membran', 'WdShake', 
                                                      'WdShngl'])
  logging.info("Primer procesamiento: exitoso")

  #Decofificar variables categóricas
  preprocesamiento_datos.codificar_columnas_cat(train_data, test_data, 
                                                ['Street' ,'BldgType', 
                                                'SaleType', 'CentralAir'])
  logging.info("Segundo prosesamiento: exitoso")
  #Suma y multiplicación de variables para crear nuevas variables
  train_data['BsmtRating'] = preprocesamiento_datos.mult_variables(
      train_data, ['BsmtCond', 'BsmtQual'])
  test_data['BsmtRating'] = preprocesamiento_datos.mult_variables(
      test_data,['BsmtCond', 'BsmtQual'])

  train_data['ExterRating'] = preprocesamiento_datos.mult_variables(
      train_data,['ExterCond','ExterQual'])
  test_data['ExterRating'] = preprocesamiento_datos.mult_variables(
    test_data, ['ExterCond', 'ExterQual'])

  train_data['BsmtFinTypeRating'] = preprocesamiento_datos.mult_variables(
      train_data, ['BsmtFinType1', 'BsmtFinType2'])
  test_data['BsmtFinTypeRating'] = preprocesamiento_datos.mult_variables(
      test_data, ['BsmtFinType1', 'BsmtFinType2'])

  train_data['BsmtBath'] = preprocesamiento_datos.suma_variables(
      train_data, ['BsmtFullBath', 'BsmtHalfBath'])
  test_data['BsmtBath'] = preprocesamiento_datos.suma_variables(
      test_data, ['BsmtFullBath', 'BsmtHalfBath'])

  train_data['Bath'] = preprocesamiento_datos.suma_variables(
      train_data, ['FullBath', 'HalfBath'])
  test_data['Bath'] = preprocesamiento_datos.suma_variables(
      test_data, ['FullBath', 'HalfBath'])

  train_data['PorchArea'] = preprocesamiento_datos.suma_variables(
      train_data, ['OpenPorchSF', 'EnclosedPorch','3SsnPorch', 'ScreenPorch'])
  test_data['PorchArea'] = preprocesamiento_datos.suma_variables(
      test_data,['OpenPorchSF', 'EnclosedPorch','3SsnPorch', 'ScreenPorch'])
  
  logging.info("Tercer prosesamiento: exitoso")

except KeyError as error:
  logging.error("Alguna de las variables seleccionadas no existe.\
  No fue posible procesar las variables categóricas.")
  logging.debug(error)
except NameError as error2:
  logging.error("El nombre de alguna base es erróneo.\
  No fue posible procesar las variables categóricas.")
  logging.debug(error2)

try:
  #Quitar columnas especificadas
  drop_col = ['OverallQual', 
              'ExterCond', 'ExterQual',
              'BsmtCond', 'BsmtQual',
              'BsmtFinType1', 'BsmtFinType2',
              'HeatingQC',
              'OpenPorchSF', 'EnclosedPorch', '3SsnPorch', 'ScreenPorch',
              'BsmtFullBath', 'BsmtHalfBath',
              'FullBath', 'HalfBath',
            ]

  limpieza_datos.quitar_columnas(train_data, drop_col)
  limpieza_datos.quitar_columnas(test_data, drop_col)

  logging.debug(f"Tamaño base 2 = {train_data.shape}")

except KeyError as error:
  logging.error("Alguna de las variables seleccionadas no existe.\
  No fue posible quitar las variables seleccionadas.")
  logging.debug(error)
except NameError as error2:
  logging.error("El nombre de alguna base es erróneo.\
  No fue posible quitar las variables seleccionadas.")
  logging.debug(error2)

"""## Model"""

try: 
  #Definir modelo a usar
  modelo_bosque = modelo.modelo_bosques_aleatorios(250)

  #Estimar el modelo
  ajuste = modelo.ajuste_modelo_bosques_aleatorio(train_data, modelo_bosque, 
                                                  'SalePrice')

  #Calcular la métrica del modelo estimado
  metrica = modelo.metrica(modelo_bosque, train_data,'SalePrice')
  #Impresión de la métrica
  logging.info(f"La métrica del modelo es = {metrica}")
except KeyError as error:
  logging.error("La variable seleccionada como variable dependiente no existe.\
  No fue posible ajustar el modelo.")
  logging.debug(error)
except NameError as error2:
  logging.error("El nombre de alguna base o del modelo es erróneo.\
  No fue posible ajustar el modelo.")
  logging.debug(error2)
except ValueError as error3:
  logging.error("El hiperparámetro del modelo no es válido (debe ser mayor a 0)\
  No fue posible ajustar el modelo.")
  logging.debug(error3)

"""## Final output"""

try:
  #Calcular predicciones del modelo estimado e imprimirlas en un csv
  estimaciones = modelo.estimacion(modelo_bosque, test_data, test_ids)

except NameError as error:
  logging.error("El nombre de alguna base o del modelo es erróneo.\
  No fue posible obtener las estimaciones del modelo.")

